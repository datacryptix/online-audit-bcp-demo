<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HIS BCP ‚Äì Data of BCP Documents & Forms (Demo)</title>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- jsPDF + AutoTable (order matters: jsPDF first, then AutoTable) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
  <!-- Signature Pad -->
  <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.2.0/dist/signature_pad.umd.min.js"></script>
  <style>
    html, body { height: 100%; }
    /* keep plain classes (no @apply) to avoid Tailwind build step */
    .card { background:#fff; border:1px solid rgb(228 228 231); border-radius:1rem; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .btn { background:#fff; border:1px solid rgb(212 212 216); border-radius:0.75rem; padding:.5rem 1rem; box-shadow:0 1px 2px rgba(0,0,0,.04); transition:box-shadow .2s; }
    .btn:hover { box-shadow:0 2px 6px rgba(0,0,0,.07); }
    .btn-primary { background:#2563eb; color:#fff; border-color:#1d4ed8; }
    .btn-primary:hover { background:#1d4ed8; }
    .tab-active { background:#eff6ff; color:#1d4ed8; border-color:#bfdbfe; }
    .label { font-size:.875rem; color:rgb(82 82 91); display:block; margin-bottom:.25rem; }
    .input { width:100%; background:#fff; border:1px solid rgb(212 212 216); border-radius:.75rem; padding:.5rem .75rem; }
    .checkbox { width:1.25rem; height:1.25rem; border:1px solid rgb(212 212 216); border-radius:.25rem; }
  </style>
</head>
<body class="min-h-full bg-white text-zinc-900">
  <div class="max-w-6xl mx-auto p-4 sm:p-6 space-y-6">
    <header class="flex items-center justify-between gap-4 flex-wrap">
      <div>
        <h1 class="text-2xl sm:text-3xl font-bold">Data of BCP Documents & Forms ‚Äì Demo</h1>
        <p class="text-sm text-zinc-600">HIS Business Continuity Plan ‚Äì Audit of Manual Forms & Downtime Labels</p>
      </div>
      <div class="flex items-center gap-2 flex-wrap">
        <button id="btnMode" class="btn">Switch to Auditor Mode</button>
        <button id="btnNew" class="btn" title="Clear current form">New</button>
        <button id="btnSave" class="btn btn-primary" title="Save to database and local file">Save</button>
        <button id="btnPDF" class="btn" title="Export current form as PDF">Export PDF</button>
        <div class="relative group">
          <button id="btnDataMenu" class="btn" title="Data backup/export/import">üìä Data</button>
          <div id="dataMenu" class="absolute right-0 top-full mt-1 bg-white border border-zinc-300 rounded-lg shadow-lg p-2 min-w-48 hidden group-hover:block z-10">
            <button id="btnExportJSON" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üìÑ Export JSON</button>
            <button id="btnExportCSV" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üìä Export CSV</button>
            <button id="btnImportJSON" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üì• Import JSON</button>
            <button id="btnLoadRecord" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üìÇ Load Record File</button>
            <button id="btnBackupAll" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üíæ Backup All Data</button>
            <button id="btnRestoreBackup" class="block w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded">üîÑ Restore Backup</button>
            <hr class="my-1">
            <button id="btnClearAll" class="block w-full text-left px-3 py-2 text-sm hover:bg-red-50 text-red-600 rounded">üóëÔ∏è Clear All Data</button>
            <button id="btnResetDB" class="block w-full text-left px-3 py-2 text-sm hover:bg-red-50 text-red-600 rounded">üîÑ Reset Database</button>
          </div>
        </div>
      </div>
    </header>

    <!-- Tabs -->
    <nav class="flex gap-2">
      <button data-tab="tab-form" class="btn tab-active">Fill Form</button>
      <button data-tab="tab-history" class="btn">History</button>
    </nav>

    <!-- Form Card -->
    <section id="tab-form" class="card p-4 sm:p-6 space-y-6">
      <h2 class="text-xl font-semibold">Form Entry</h2>

      <!-- Meta -->
      <div class="grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <div>
          <label class="label">Area / Section / Unit</label>
          <input id="unit" class="input" placeholder="e.g., Ward 2A" />
        </div>
        <div>
          <label class="label">Date of Audit</label>
          <input id="auditDate" type="date" class="input" />
        </div>
        <div>
          <label class="label">Series</label>
          <input id="series" class="input" placeholder="e.g., 6" />
        </div>
        <div>
          <label class="label">Prepared by (typed name)</label>
          <input id="signerName" class="input" placeholder="Officer in charge" />
        </div>
      </div>

      <!-- Checklist -->
      <div class="space-y-3">
        <div class="flex items-center justify-between flex-wrap gap-2">
          <h1 class="text-lg font-medium">BCP Forms & Labels</h1>
          <div class="flex gap-2">
            <button id="btnToggleAll" class="btn" title="Toggle all checkboxes">Check All</button>
          </div>
        </div>
        <div id="items" class="space-y-3"></div>
      </div>

      <!-- Remarks -->
      <div>
        <label class="label">Remarks</label>
        <textarea id="remarks" rows="4" class="input" placeholder="Enter any notes (e.g., forms prepared and labeled; minimum 5 copies available)"></textarea>
      </div>

      <!-- Signature -->
      <div class="grid md:grid-cols-2 gap-4">
        <div class="space-y-2">
          <label class="label">Draw Signature (mouse/touch)</label>
          <div class="card p-3">
            <canvas id="sigCanvas" class="w-full h-48 bg-white rounded-xl border border-zinc-300"></canvas>
          </div>
          <div class="flex gap-2">
            <button id="btnClearSig" class="btn">Clear Signature</button>
            <button id="btnUseTypedSig" class="btn" title="Create signature from typed name">Use typed name</button>
          </div>
          <p class="text-xs text-zinc-500">Only one signature (Unit/Ward) is required in this demo.</p>
        </div>
        <div class="space-y-2">
          <label class="label">Signature Preview</label>
          <div class="card p-3 h-48 flex items-center justify-center">
            <img id="sigPreview" alt="Signature Preview" class="max-h-40" />
          </div>
        </div>
      </div>

      <input id="currentId" type="hidden" />
      <input id="currentUuid" type="hidden" />
    </section>

    <!-- History Card -->
    <section id="tab-history" class="card p-4 sm:p-6 space-y-4 hidden">
      <h2 class="text-xl font-semibold">Audit History</h2>
      <div class="grid sm:grid-cols-3 gap-3">
        <input id="filterUnit" class="input" placeholder="Filter by Unit/Ward" />
        <input id="filterSeries" class="input" placeholder="Filter by Series" />
        <input id="filterDate" type="date" class="input" placeholder="Filter by Date" />
      </div>
      <div class="overflow-x-auto">
        <table class="w-full text-sm">
          <thead>
            <tr class="text-left border-b border-zinc-300">
              <th class="py-2 pr-2">#</th>
              <th class="py-2 pr-2">Unit</th>
              <th class="py-2 pr-2">Date</th>
              <th class="py-2 pr-2">Series</th>
              <th class="py-2 pr-2">Checked</th>
              <th class="py-2 pr-2">Actions</th>
            </tr>
          </thead>
          <tbody id="historyBody"></tbody>
        </table>
      </div>
    </section>

    <footer class="text-xs text-zinc-500 text-center py-6">Demo ‚Äì No login. Data is stored in your browser (IndexedDB). Export PDFs for records.</footer>
  </div>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    // DB setup
    const DB_NAME = 'bcp_audit_db';
    const DB_VER = 6; // Schema v6: simplify migrations; ensure store + indexes
    const STORE = 'submissions';
    let db;
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = (e) => {
          const dbInst = e.target.result;
          const tx = e.target.transaction;
          const oldVersion = e.oldVersion || 0;
          const newVersion = dbInst.version;
          console.log('Upgrading DB (simplified ensure)', { oldVersion, newVersion });

          // Ensure store exists
          let store;
          if (!dbInst.objectStoreNames.contains(STORE)) {
            store = dbInst.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
            console.log('Created object store', STORE);
          } else {
            store = tx.objectStore(STORE);
          }

          // Helper to safely create indexes if missing
          const ensureIndex = (name, keyPath, options = { unique: false }) => {
            const names = store.indexNames ? Array.from(store.indexNames) : [];
            if (!names.includes(name)) {
              try { store.createIndex(name, keyPath, options); console.log('Created index', name, 'on', keyPath); }
              catch (err) { console.warn('createIndex failed for', name, err); }
            } else {
              console.log('Index exists, skipping:', name);
            }
          };

          // Ensure all indexes (id store already set)
          ensureIndex('unit_idx', 'unit');
          ensureIndex('auditDate_idx', 'auditDate');
          ensureIndex('series_idx', 'series');
          ensureIndex('createdAt_idx', 'createdAt');
          ensureIndex('uuid_idx', 'uuid'); // keep non-unique for resilience
          ensureIndex('unit_date_series_idx', ['unit','auditDate','series']);
        };
        req.onsuccess = () => {
          db = req.result;
          console.log('Database opened successfully, version:', db.version);
          resolve(db);
        };
        req.onerror = (e) => {
          console.error('Database open error:', e.target.error);
          reject(e.target.error);
        };
      });
    }
    function txStore(mode='readonly') { return db.transaction(STORE, mode).objectStore(STORE); }
    
    async function dbAdd(data){ 
      return new Promise((res,rej)=>{
        try {
          // Remove id field for new records to let autoIncrement work
          const { id, ...dataWithoutId } = data;
          
          console.log('Attempting to add data to IndexedDB:', { 
            unit: dataWithoutId.unit, 
            auditDate: dataWithoutId.auditDate,
            signatureLength: dataWithoutId.signature ? dataWithoutId.signature.length : 0,
            itemsCount: dataWithoutId.items ? dataWithoutId.items.length : 0
          });
          
          const r = txStore('readwrite').add(dataWithoutId); 
          r.onsuccess=()=>res(r.result); 
          r.onerror=(e)=>{
            console.error('IndexedDB add error:', e.target.error);
            rej(e.target.error);
          }
        } catch (error) {
          console.error('Error in dbAdd:', error);
          rej(error);
        }
      }); 
    }
    
    async function dbPut(data){ 
      return new Promise((res,rej)=>{
        try {
          console.log('Attempting to update data in IndexedDB:', { 
            id: data.id, 
            unit: data.unit, 
            auditDate: data.auditDate,
            signatureLength: data.signature ? data.signature.length : 0,
            itemsCount: data.items ? data.items.length : 0
          });
          const r = txStore('readwrite').put(data); 
          r.onsuccess=()=>res(r.result); 
          r.onerror=(e)=>{
            console.error('IndexedDB put error:', e.target.error);
            rej(e.target.error);
          }
        } catch (error) {
          console.error('Error in dbPut:', error);
          rej(error);
        }
      }); 
    }
    
    async function dbGet(id){ return new Promise((res,rej)=>{ const r = txStore().get(id); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function dbAll(){ return new Promise((res,rej)=>{ const r = txStore().getAll(); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function dbFindByUuid(uuid){
      return new Promise((resolve, reject)=>{
        try{
          const idx = txStore().index('uuid_idx');
          const req = idx.get(uuid);
          req.onsuccess = ()=> resolve(req.result || null);
          req.onerror = ()=> reject(req.error);
        }catch(err){ resolve(null); }
      });
    }
    async function dbFindByComposite(unit, auditDate, series){
      return new Promise((resolve, reject)=>{
        try{
          const idx = txStore().index('unit_date_series_idx');
          const key = [unit, auditDate, series];
          // de-dupe should treat any match as existing, even if multiple duplicates exist
          const req = idx.getKey(key);
          req.onsuccess = ()=> resolve(req.result ? true : false);
          req.onerror = ()=> reject(req.error);
        }catch(err){ resolve(false); }
      });
    }
    async function dbDel(id){ return new Promise((res,rej)=>{ const r = txStore('readwrite').delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); }); }

    // Items
    const TEMPLATE_ITEMS = [
      'Admission','Appointment Request','Assign Bed Mark Patient Arrival','Blood Donor','Blood Transfusion','Body Part Registration',
      'Check Out','Collection','Decease Registration','Discharge Summary','Donor Screening','Downtime Encounter Sheet',
      'Inpatient Discharge','Inpatient Discharge Advice','Inpatient Transfer Form','Inventory Request','Medication Order',
      'Newborn Registration','Patient Registration','Lab Investigation (Per Pat)','Referral Registration','Register Attendance',
      'Register Visit','Secondary Triage','Result Reporting','Generic Referral','New Order','Specimen Downtime Label',
      'Admission Downtime Label',
    ];

    function makeItemRow(name, idx) {
      const id = `item_${idx}`;
      return `
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 p-3 rounded-xl border border-zinc-200 bg-white shadow-sm">
          <label class="flex items-center gap-3 text-sm font-medium">
            <input type="checkbox" class="checkbox" id="${id}_chk" />
            <span>${idx + 1}. ${name}</span>
          </label>
          <div class="flex items-center gap-2">
            <label for="${id}_date" class="label whitespace-nowrap m-0">Date of Usage</label>
            <input type="date" class="input" id="${id}_date" />
          </div>
        </div>
      `;
    }
    function renderItems(){ $('#items').innerHTML = TEMPLATE_ITEMS.map((nm,i)=>makeItemRow(nm,i)).join(''); }

    // Signature
    let sigPad;
    function initSignaturePad(){
      const c = document.getElementById('sigCanvas');
      const dpr = window.devicePixelRatio || 1;
      function resizeCanvas(){
        const rect = c.getBoundingClientRect();
        c.width = rect.width * dpr;
        c.height = rect.height * dpr;
        const ctx = c.getContext('2d'); ctx.scale(dpr, dpr);
        if(sigPad) sigPad.clear();
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      sigPad = new SignaturePad(c, { penColor: '#0a0a0a' });
    }
    function updateSigPreview(dataUrl){ $('#sigPreview').src = dataUrl || ''; }
    function typedSignatureToDataUrl(name){
      const canvas = document.createElement('canvas'); canvas.width=600; canvas.height=180;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#111827'; ctx.font='36px Brush Script MT, Comic Sans MS, cursive';
      ctx.fillText(name||'',30,110);
      return canvas.toDataURL('image/png');
    }

    // Collect form
    function collectForm(){
      const items = TEMPLATE_ITEMS.map((name,i)=>({
        name, checked: document.getElementById(`item_${i}_chk`).checked,
        date: document.getElementById(`item_${i}_date`).value || ''
      }));
      return {
        id: $('#currentId').value ? Number($('#currentId').value) : undefined,
        uuid: $('#currentUuid').value || (crypto && crypto.randomUUID ? crypto.randomUUID() : (Date.now().toString(36)+Math.random().toString(36).slice(2))),
        unit: $('#unit').value.trim(),
        auditDate: $('#auditDate').value,
        series: $('#series').value.trim(),
        signerName: $('#signerName').value.trim(),
        remarks: $('#remarks').value.trim(),
        signature: $('#sigPreview').src || '',
        items,
        createdAt: new Date().toISOString()
      };
    }
    function fillForm(data){
      $('#currentId').value = data?.id || '';
      $('#currentUuid').value = data?.uuid || '';
      $('#unit').value = data?.unit || '';
      $('#auditDate').value = data?.auditDate || '';
      $('#series').value = data?.series || '';
      $('#signerName').value = data?.signerName || '';
      $('#remarks').value = data?.remarks || '';
      updateSigPreview(data?.signature || '');
      (data?.items || []).forEach((it,i)=>{
        document.getElementById(`item_${i}_chk`).checked = !!it.checked;
        document.getElementById(`item_${i}_date`).value = it.date || '';
      });
    }
    function clearForm(){ fillForm({ items: TEMPLATE_ITEMS.map(()=>({})) }); $('#currentId').value=''; if(sigPad) sigPad.clear(); updateSigPreview(''); }

    // Toggle all checkboxes function
    function toggleAllCheckboxes() {
      const checkboxes = document.querySelectorAll('#items input[type="checkbox"]');
      const allChecked = Array.from(checkboxes).every(cb => cb.checked);
      
      // Toggle all checkboxes to the opposite state
      checkboxes.forEach(checkbox => {
        checkbox.checked = !allChecked;
      });
      
      // Update button text
      const button = document.getElementById('btnToggleAll');
      button.textContent = allChecked ? 'Check All' : 'Uncheck All';
      button.title = allChecked ? 'Check all checkboxes' : 'Uncheck all checkboxes';
    }

    // Local file save functionality
    async function saveToLocalFile(data) {
      try {
        // Create a safe filename
        const safeUnit = (data.unit || 'Unknown').replace(/[^a-zA-Z0-9]/g, '_');
        const safeDate = data.auditDate || new Date().toISOString().slice(0, 10);
        const safeSeries = (data.series || '0').replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `bcp_audit_${safeUnit}_${safeDate}_series_${safeSeries}.json`;
        
        // Prepare the data for saving
        const fileData = {
          version: '1.0',
          savedAt: new Date().toISOString(),
          record: data,
          metadata: {
            filename: filename,
            totalItems: data.items ? data.items.length : 0,
            checkedItems: data.items ? data.items.filter(item => item.checked).length : 0
          }
        };

        // Create and download the file
        const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        return filename;
      } catch (error) {
        console.error('Local file save failed:', error);
        throw new Error('Failed to save file locally: ' + error.message);
      }
    }

    // Data validation and cleaning
    async function cleanDataForStorage(data) {
      const cleaned = { ...data };
      
      // Clean signature data - remove if it's too large or invalid
      if (cleaned.signature) {
        // Check if signature is a valid data URL
        if (!cleaned.signature.startsWith('data:image/')) {
          console.warn('Invalid signature format, removing signature');
          cleaned.signature = '';
        } else {
          // Try to compress signature if it's too large
          const base64Length = cleaned.signature.length;
          const estimatedSize = Math.ceil(base64Length * 0.75); // Base64 is ~75% of original size
          
          if (estimatedSize > 1024 * 1024) { // 1MB limit
            console.warn('Signature too large, attempting compression...');
            try {
              cleaned.signature = await compressSignature(cleaned.signature);
              const newSize = Math.ceil(cleaned.signature.length * 0.75);
              if (newSize > 1024 * 1024) {
                console.warn('Signature still too large after compression, removing');
                cleaned.signature = '';
              } else {
                console.log('Signature compressed successfully');
              }
            } catch (error) {
              console.warn('Signature compression failed, removing signature:', error);
              cleaned.signature = '';
            }
          }
        }
      }
      
      // Ensure all string fields are strings and not too long
      const stringFields = ['unit', 'auditDate', 'series', 'signerName', 'remarks'];
      stringFields.forEach(field => {
        if (cleaned[field] && typeof cleaned[field] === 'string') {
          cleaned[field] = cleaned[field].trim().substring(0, 1000); // Limit to 1000 chars
        } else if (cleaned[field] !== undefined && cleaned[field] !== null) {
          cleaned[field] = String(cleaned[field]).trim().substring(0, 1000);
        } else {
          cleaned[field] = '';
        }
      });
      
      // Ensure items array is valid
      if (!Array.isArray(cleaned.items)) {
        cleaned.items = [];
      } else {
        cleaned.items = cleaned.items.map(item => ({
          name: String(item.name || '').substring(0, 200),
          checked: Boolean(item.checked),
          date: String(item.date || '').substring(0, 50)
        }));
      }
      
      // Ensure dates are valid
      if (cleaned.createdAt && !isValidDate(cleaned.createdAt)) {
        cleaned.createdAt = new Date().toISOString();
      }
      
      return cleaned;
    }
    
    function isValidDate(dateString) {
      const date = new Date(dateString);
      return date instanceof Date && !isNaN(date);
    }
    
    // Compress signature by reducing quality and size
    function compressSignature(dataUrl) {
      return new Promise((resolve, reject) => {
        try {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Reduce size
            const maxWidth = 400;
            const maxHeight = 200;
            let { width, height } = img;
            
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
            if (height > maxHeight) {
              width = (width * maxHeight) / height;
              height = maxHeight;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Draw and compress
            ctx.drawImage(img, 0, 0, width, height);
            const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7); // 70% quality
            
            resolve(compressedDataUrl);
          };
          img.onerror = reject;
          img.src = dataUrl;
        } catch (error) {
          console.error('Signature compression error:', error);
          resolve(dataUrl); // Return original if compression fails
        }
      });
    }

    async function saveRecord(data) {
      try {
        // Clean and validate data before saving
        const cleanedData = await cleanDataForStorage(data);
        
        let recordId;
        
        // Try to save to IndexedDB
        try {
          if (cleanedData.id) {
            await dbPut(cleanedData);
            recordId = cleanedData.id;
          } else {
            recordId = await dbAdd(cleanedData);
            cleanedData.id = recordId;
            $('#currentId').value = recordId;
          }
        } catch (dbError) {
          console.warn('IndexedDB save failed, trying without signature:', dbError);
          
          // Try again without signature if it's causing issues
          const dataWithoutSignature = { ...cleanedData, signature: '' };
          if (dataWithoutSignature.id) {
            await dbPut(dataWithoutSignature);
            recordId = dataWithoutSignature.id;
          } else {
            recordId = await dbAdd(dataWithoutSignature);
            dataWithoutSignature.id = recordId;
            $('#currentId').value = recordId;
          }
          
          console.log('Saved successfully without signature');
        }

        // Save to local file (use original data for file to preserve signature)
        const filename = await saveToLocalFile(data);
        
        return { recordId, filename };
      } catch (error) {
        console.error('Save failed:', error);
        throw error;
      }
    }

    // History (index-aware querying)
    async function queryRecordsByIndex({ fUnit, fSeries, fDate, limit = 1000 }){
      // Use auditDate index when provided; otherwise scan createdAt desc
      try {
        const results = [];
        const transaction = db.transaction(STORE, 'readonly');
        const store = transaction.objectStore(STORE);
        let source;
        let range = undefined;
        let direction = 'prev';
        if (fDate) {
          source = store.index('auditDate_idx');
          range = IDBKeyRange.only(fDate);
        } else if (store.indexNames && Array.from(store.indexNames).includes('createdAt_idx')) {
          source = store.index('createdAt_idx');
        } else {
          source = store; // fallback
          direction = 'next';
        }
        return await new Promise((resolve, reject)=>{
          const cursorReq = source.openCursor(range, direction);
          cursorReq.onerror = (e)=>reject(e.target.error);
          cursorReq.onsuccess = (e)=>{
            const cursor = e.target.result;
            if (!cursor) return resolve(results);
            const r = cursor.value;
            const matches = (!fUnit || (r.unit||'').toLowerCase().includes(fUnit)) &&
                           (!fSeries || (r.series||'').toLowerCase().includes(fSeries));
            if (matches) results.push(r);
            if (results.length >= limit) return resolve(results);
            cursor.continue();
          };
        });
      } catch (err) {
        console.warn('Index query failed, falling back to full scan:', err);
        const list = await dbAll();
        return list;
      }
    }

    async function renderHistory(){
      const fUnit = $('#filterUnit').value.trim().toLowerCase();
      const fSeries = $('#filterSeries').value.trim().toLowerCase();
      const fDate = $('#filterDate').value;
      const list = await queryRecordsByIndex({ fUnit, fSeries, fDate, limit: 1000 });
      const tbody = $('#historyBody'); tbody.innerHTML='';
      // If using createdAt index prev, list is already roughly newest-first.
      // Keep a stable sort by auditDate desc then id desc for consistency.
      list.sort((a,b)=> (b.auditDate||'').localeCompare(a.auditDate||'') || ((b.id||0)-(a.id||0)));
      list.forEach((r,idx)=>{
        const checkedCount = (r.items||[]).filter(i=>i.checked).length;
        const tr = document.createElement('tr');
        tr.className='border-b border-zinc-200';
        tr.innerHTML=`
          <td class="py-2 pr-2">${idx+1}</td>
          <td class="py-2 pr-2">${r.unit||''}</td>
          <td class="py-2 pr-2">${r.auditDate||''}</td>
          <td class="py-2 pr-2">${r.series||''}</td>
          <td class="py-2 pr-2">${checkedCount}</td>
          <td class="py-2 pr-2 flex gap-2">
            <button class="btn" data-act="load" data-id="${r.id}">Open</button>
            <button class="btn" data-act="pdf" data-id="${r.id}">PDF</button>
            <button class="btn" data-act="del" data-id="${r.id}">Delete</button>
          </td>`;
        tbody.appendChild(tr);
      });
    }

    // Robust PDF Export
    function exportPDF(recordRaw) {
      const record = recordRaw || collectForm();

      // Basic guards
      if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("jsPDF failed to load. Check your network or CDN.");
        console.error("window.jspdf/jsPDF not found", window.jspdf);
        return;
      }
      if (!window.jspdf.jsPDF.API || typeof window.jspdf.jsPDF.API.autoTable !== "function") {
        // plugin attaches to jsPDF.API.autoTable ‚Äî if missing, we can still export a basic PDF
        console.warn("AutoTable plugin missing ‚Äî exporting a minimal PDF without table.");
      }

      const doc = new window.jspdf.jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });

      // Title
      doc.setFont('helvetica', 'bold'); doc.setFontSize(14);
      doc.text("HIS BCP ‚Äì Data of BCP Documents & Forms", 40, 40);
      doc.setFontSize(10); doc.setFont('helvetica','');
      doc.text("HIS BUSINESS CONTINUITY PLAN", 40, 58);

      // Metadata
      doc.setFontSize(10);
      const metaY = 80;
      doc.text(`Unit/Ward: ${record.unit || ""}`, 40, metaY);
      doc.text(`Audit Date: ${record.auditDate || ""}`, 300, metaY);
      doc.text(`Series: ${record.series || ""}`, 40, metaY + 18);
      doc.text(`Prepared by: ${record.signerName || ""}`, 300, metaY + 18);

      let y = metaY + 36;

      // Table (if plugin present)
      if (typeof doc.autoTable === "function") {
        const tableData = (record.items || []).map((it, i) => [
          i + 1, it.name, it.checked ? "‚úì" : "", it.date || ""
        ]);
        doc.autoTable({
          startY: y,
          head: [["#", "Form / Label", "Checked", "Date of Usage"]],
          body: tableData,
          styles: { fontSize: 9, cellPadding: 4 },
          headStyles: { fillColor: [59, 130, 246], textColor: 255 }
        });
        y = (doc.lastAutoTable && doc.lastAutoTable.finalY) ? doc.lastAutoTable.finalY + 20 : y + 20;
      } else {
        // Fallback simple list if plugin missing
        doc.setFontSize(10);
        doc.text("Forms (AutoTable plugin missing):", 40, y);
        y += 14;
        (record.items || []).forEach((it, i) => {
          doc.text(`${i + 1}. ${it.name}  ${it.checked ? "‚úì" : ""}  ${it.date || ""}`, 40, y);
          y += 12;
          if (y > 700) { doc.addPage(); y = 40; }
        });
        y += 10;
      }

      // Remarks
      doc.setFont('helvetica','bold'); doc.text("Remarks:", 40, y); doc.setFont('helvetica','');
      y += 12;
      doc.setDrawColor(200); doc.setLineWidth(0.5);
      doc.rect(40, y, 515, 60);
      const remarkText = record.remarks || "-";
      doc.setFontSize(9);
      doc.text(remarkText, 48, y + 16, { maxWidth: 499 });
      y += 80;

      // Signature
      doc.setFont('helvetica','bold'); doc.setFontSize(10);
      doc.text("Unit/Ward Signature:", 40, y); y += 8; doc.setFont('helvetica','');
      if (record.signature) {
        try { doc.addImage(record.signature, "PNG", 40, y + 6, 200, 60); }
        catch (e) { console.warn("Signature image add failed:", e); }
      }
      doc.text((record.signerName || ""), 250, y + 26);
      if (record.auditDate) doc.text(`Date: ${record.auditDate}`, 250, y + 46);

      // Footer
      doc.setFontSize(8);
      doc.text(`Generated on ${new Date().toLocaleString()}`, 40, doc.internal.pageSize.height - 30);

      const filename = `BCP_Audit_${(record.unit || "Unit").replace(/\s+/g,'_')}_${record.auditDate || "Date"}.pdf`;
      try {
        doc.save(filename);
      } catch (e) {
        console.error("doc.save failed:", e);
        alert("PDF save failed. See console for details.");
      }
    }

    // Data Export/Import Functions
    async function exportJSON() {
      try {
        const data = await dbAll();
        const exportData = {
          version: '1.0',
          exportDate: new Date().toISOString(),
          recordCount: data.length,
          data: data
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `bcp_audit_backup_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`Exported ${data.length} records successfully!`);
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed: ' + error.message);
      }
    }

    async function exportCSV() {
      try {
        const data = await dbAll();
        if (data.length === 0) {
          alert('No data to export.');
          return;
        }

        // Create CSV header
        const headers = ['ID', 'Unit', 'Audit Date', 'Series', 'Signer Name', 'Checked Items', 'Total Items', 'Created At'];
        let csvContent = headers.join(',') + '\n';

        // Add data rows
        data.forEach(record => {
          const checkedCount = (record.items || []).filter(item => item.checked).length;
          const totalCount = record.items ? record.items.length : 0;
          const row = [
            record.id,
            `"${(record.unit || '').replace(/"/g, '""')}"`,
            record.auditDate || '',
            `"${(record.series || '').replace(/"/g, '""')}"`,
            `"${(record.signerName || '').replace(/"/g, '""')}"`,
            checkedCount,
            totalCount,
            record.createdAt || ''
          ];
          csvContent += row.join(',') + '\n';
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `bcp_audit_summary_${new Date().toISOString().slice(0,10)}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`Exported ${data.length} records to CSV successfully!`);
      } catch (error) {
        console.error('CSV export failed:', error);
        alert('CSV export failed: ' + error.message);
      }
    }

    async function importJSON() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.multiple = true; // Allow multiple files
      input.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        try {
          let totalImported = 0;
          let totalSkipped = 0;

          for (const file of files) {
            try {
              const text = await file.text();
              const importData = JSON.parse(text);
              
              // Handle different file formats
              let records = [];
              if (importData.data && Array.isArray(importData.data)) {
                // Backup format with data array
                records = importData.data;
              } else if (importData.record) {
                // Single record format
                records = [importData.record];
              } else if (Array.isArray(importData)) {
                // Direct array format
                records = importData;
              } else {
                console.warn(`Skipping file ${file.name}: Invalid format`);
                totalSkipped++;
                continue;
              }

              if (records.length === 0) {
                console.warn(`Skipping file ${file.name}: No records found`);
                totalSkipped++;
                continue;
              }

              let imported = 0;
              let skipped = 0;
              
              for (const record of records) {
                try {
                  // Normalize minimal fields used for de-dupe
                  const unit = (record.unit || '').trim();
                  const auditDate = record.auditDate || '';
                  const series = (record.series || '').trim();

                  // Prefer uuid when available
                  let exists = false;
                  if (record.uuid) {
                    const byUuid = await dbFindByUuid(record.uuid);
                    exists = !!byUuid; // get returns null when not found
                  }
                  if (!exists) {
                    const byComposite = await dbFindByComposite(unit, auditDate, series);
                    exists = !!byComposite; // boolean
                  }

                  if (exists) {
                    skipped++;
                    console.info('Duplicate skipped (import):', { unit, auditDate, series, uuid: record.uuid });
                    continue;
                  }

                  // Remove the id to create new records; ensure uuid exists
                  const { id, ...recordData } = record;
                  if (!recordData.uuid) {
                    recordData.uuid = crypto && crypto.randomUUID ? crypto.randomUUID() : (Date.now().toString(36)+Math.random().toString(36).slice(2));
                  }
                  await dbAdd(recordData);
                  imported++;
                } catch (error) {
                  console.warn('Failed to import record:', error);
                  skipped++;
                }
              }

              totalImported += imported;
              totalSkipped += skipped;
              
            } catch (error) {
              console.error(`Failed to process file ${file.name}:`, error);
              totalSkipped++;
            }
          }

          alert(`Import completed!\nImported: ${totalImported} records\nSkipped (duplicates/errors): ${totalSkipped}`);
          renderHistory();
        } catch (error) {
          console.error('Import failed:', error);
          alert('Import failed: ' + error.message);
        }
      };
      input.click();
    }

    async function backupAllData() {
      try {
        const data = await dbAll();
        const backupData = {
          version: '1.0',
          backupDate: new Date().toISOString(),
          recordCount: data.length,
          data: data,
          metadata: {
            databaseName: DB_NAME,
            databaseVersion: DB_VER,
            storeName: STORE
          }
        };

        const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `bcp_audit_full_backup_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`Full backup created with ${data.length} records!`);
      } catch (error) {
        console.error('Backup failed:', error);
        alert('Backup failed: ' + error.message);
      }
    }

    async function restoreBackup() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          const backupData = JSON.parse(text);
          
          if (!backupData.data || !Array.isArray(backupData.data)) {
            throw new Error('Invalid backup file format.');
          }

          const recordCount = backupData.data.length;
          if (recordCount === 0) {
            alert('No records found in backup file.');
            return;
          }

          if (!confirm(`Restore ${recordCount} records? This will REPLACE all existing data!`)) {
            return;
          }

          // Clear existing data
          const clearReq = txStore('readwrite').clear();
          await new Promise((resolve, reject) => {
            clearReq.onsuccess = resolve;
            clearReq.onerror = reject;
          });

          // Import backup data
          let restored = 0;
          let failed = 0;
          
          for (const record of backupData.data) {
            try {
              const { id, ...recordData } = record;
              await dbAdd(recordData);
              restored++;
            } catch (error) {
              console.warn('Failed to restore record:', error);
              failed++;
            }
          }

          alert(`Restore completed!\nRestored: ${restored} records\nFailed: ${failed} records`);
          renderHistory();
        } catch (error) {
          console.error('Restore failed:', error);
          alert('Restore failed: ' + error.message);
        }
      };
      input.click();
    }

    async function loadRecordFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          const fileData = JSON.parse(text);
          
          let record;
          if (fileData.record) {
            // Single record format
            record = fileData.record;
          } else if (fileData.data && Array.isArray(fileData.data) && fileData.data.length > 0) {
            // Backup format - take first record
            record = fileData.data[0];
          } else if (Array.isArray(fileData) && fileData.length > 0) {
            // Direct array format - take first record
            record = fileData[0];
          } else {
            throw new Error('No valid record found in file.');
          }

          // Load the record into the form
          fillForm(record);
          switchTab('tab-form');
          
          alert(`Record loaded successfully from ${file.name}`);
        } catch (error) {
          console.error('Load record failed:', error);
          alert('Failed to load record: ' + error.message);
        }
      };
      input.click();
    }

    async function clearAllData() {
      if (!confirm('Are you sure you want to delete ALL data? This action cannot be undone!')) {
        return;
      }

      try {
        const clearReq = txStore('readwrite').clear();
        await new Promise((resolve, reject) => {
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });

        alert('All data has been cleared successfully.');
        renderHistory();
        clearForm();
      } catch (error) {
        console.error('Clear data failed:', error);
        alert('Failed to clear data: ' + error.message);
      }
    }

    // Function to completely reset the database
    async function resetDatabase() {
      if (!confirm('This will completely delete and recreate the database. All data will be lost. Continue?')) {
        return;
      }

      try {
        // Close current database connection
        if (db) {
          db.close();
        }

        // Delete the database
        const deleteReq = indexedDB.deleteDatabase(DB_NAME);
        await new Promise((resolve, reject) => {
          deleteReq.onsuccess = resolve;
          deleteReq.onerror = reject;
        });

        console.log('Database deleted successfully');

        // Reopen database (this will trigger onupgradeneeded)
        await openDB();
        
        alert('Database has been reset successfully.');
        renderHistory();
        clearForm();
      } catch (error) {
        console.error('Database reset failed:', error);
        alert('Failed to reset database: ' + error.message);
      }
    }

    // Mode toggle
    let auditorMode = false;
    function setMode(auditor){
      auditorMode = auditor;
      document.querySelectorAll('#tab-form input, #tab-form textarea, #tab-form select').forEach(el=>{
        if(el.type!=="hidden") el.disabled = auditor;
      });
      ['btnSave','btnNew','btnClearSig','btnUseTypedSig','btnToggleAll'].forEach(id=>{
        const el=document.getElementById(id); if(el) el.style.display=auditor?'none':'';
      });
      if(auditor && sigPad) sigPad.off(); else if(!auditor && sigPad) sigPad.on();
      $('#btnMode').innerText = auditor? "Switch to Auditor Mode":"Switch to Viewer Mode";
    }

    // Tabs
    function switchTab(id){
      ['tab-form','tab-history'].forEach(t=>document.getElementById(t).classList.toggle('hidden',t!==id));
      $$('nav [data-tab]').forEach(btn=>btn.classList.toggle('tab-active',btn.dataset.tab===id));
      if(id==='tab-history') renderHistory();
    }

    (async function init(){
      renderItems(); await openDB(); initSignaturePad();
      const today = new Date().toISOString().slice(0,10);
      if(!$('#auditDate').value) $('#auditDate').value=today;

      // Tab switching
      document.querySelectorAll('nav [data-tab]').forEach(btn=>btn.addEventListener('click',()=>switchTab(btn.dataset.tab)));
      $('#btnMode').addEventListener('click',()=>setMode(!auditorMode));
      $('#btnNew').addEventListener('click',()=>clearForm());
      $('#btnSave').addEventListener('click',async()=>{
        const data=collectForm();
        if(!data.unit||!data.auditDate||!data.series){ alert("Please fill required fields."); return; }
        try{
          // De-dupe check before saving new records
          if (!data.id) {
            const existsByUuid = data.uuid ? await dbFindByUuid(data.uuid) : null;
            const existsByComposite = await dbFindByComposite(data.unit.trim(), data.auditDate, data.series.trim());
            if (existsByUuid || existsByComposite) {
              alert('Record already exists.');
              return;
            }
          }
          const { recordId } = await saveRecord(data);
          alert(`Saved successfully. Record ID: ${recordId}`);
          renderHistory();
        }catch(e){ console.error(e); alert("Error saving: "+e); }
      });

      // Toggle all checkboxes
      $('#btnToggleAll').addEventListener('click', toggleAllCheckboxes);

      // Export current form
      $('#btnPDF').addEventListener('click',()=>{ const data=collectForm(); exportPDF(data); });

      // Data management
      $('#btnDataMenu').addEventListener('click', (e) => {
        e.stopPropagation();
        const menu = $('#dataMenu');
        menu.classList.toggle('hidden');
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', () => {
        $('#dataMenu').classList.add('hidden');
      });
      
      $('#btnExportJSON').addEventListener('click', exportJSON);
      $('#btnExportCSV').addEventListener('click', exportCSV);
      $('#btnImportJSON').addEventListener('click', importJSON);
      $('#btnLoadRecord').addEventListener('click', loadRecordFile);
      $('#btnBackupAll').addEventListener('click', backupAllData);
      $('#btnRestoreBackup').addEventListener('click', restoreBackup);
      $('#btnClearAll').addEventListener('click', clearAllData);
      $('#btnResetDB').addEventListener('click', resetDatabase);

      // Signature
      $('#btnClearSig').addEventListener('click',()=>{ if(sigPad) sigPad.clear(); updateSigPreview(''); });
      $('#btnUseTypedSig').addEventListener('click',()=>{ const nm=$('#signerName').value.trim(); if(!nm){alert("Enter signer name first.");return;} const url=typedSignatureToDataUrl(nm); updateSigPreview(url); });

      // History actions
      $('#historyBody').addEventListener('click',async(e)=>{
        const btn=e.target.closest('button'); if(!btn) return;
        const id=Number(btn.dataset.id); const act=btn.dataset.act;
        const rec=await dbGet(id);
        if(act==='load'){ fillForm(rec); switchTab('tab-form'); }
        else if(act==='pdf'){ exportPDF(rec); }
        else if(act==='del'){
          if(confirm("Delete record?")){ await dbDel(id); renderHistory(); }
        }
      });
      ['filterUnit','filterSeries','filterDate'].forEach(id=>$('#'+id).addEventListener('input',renderHistory));

      clearForm(); switchTab('tab-form'); setMode(false);

      // Optional quick sanity check (prints to console)
      console.log("jsPDF loaded?", !!(window.jspdf && window.jspdf.jsPDF));
      console.log("AutoTable available?", !!(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable));
    })();
  </script>
</body>
</html>
